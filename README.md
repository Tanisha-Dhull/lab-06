# lab-06  
Author : Tanisha Dhull
ccid : tdhull
References : Open AI ChatGPT 5.0 
 
(Summary of the entire conversation, generated by ChatGPT attached below) 
 
You: I want you to act as a Java/Android Studio specialist for my Lab 6. I’ll upload the description and links. 

Me: Great—upload the lab handout plus the two slide decks (Javadoc + JUnit). I’ll read them line-by-line, extract requirements, make a checklist, and then we’ll implement exactly what they want. 

You: Uploaded. What needs to be done first? 

Me: Before the participation exercise, you must (1) review the slides, (2) create a project named “ListyCity” with package com.example.listycity, (3) add a City class with private fields for the city and province, getters, and make it comparable by city name, (4) add a CityList class with a private list, an add method that rejects duplicates by throwing an exception, and a getter that returns the list sorted, (5) configure tests, and (6) generate Javadocs to the app/javadocs folder. 

You: Where do I put the test-platform line? 

Me: In the app module’s Gradle file (the one inside app), place the test platform configuration at the very bottom, outside the Android and dependencies sections. Since you’re on Kotlin DSL, use the Kotlin-DSL form; if sync complains, we’ll remove it and stick to the runner Android Studio uses by default. 

You: I’m on Kotlin DSL—same place? 

Me: Yes, same file and same place: very bottom, outside the other blocks. If type inference errors appear, it’s a known Kotlin-DSL quirk; you can omit that block and still run unit tests fine. 

You: What should I choose as the Javadoc output directory? 

Me: The lab requires the output under the app module. Choose the app/javadocs folder in your project. 

You: Gradle sync error with the test block; I removed it and it worked. 

Me: That’s fine. Your tests can still run. Keep going. 

You: How do I check Javadocs and tests? 

Me: For tests: right-click your test file and run it; confirm all tests pass and open the generated HTML test report under your app’s build reports. For Javadocs: generate, then open the index HTML inside app/javadocs. Confirm your package page lists the two classes and that each method shows its description with parameter/return docs. 

You: Javadoc shows errors about Android types. 

Me: That happens because the Javadoc tool doesn’t see the Android SDK classes. Temporarily reference your platform’s Android SDK library so the doc tool can resolve those types, then regenerate. After it succeeds, remove that temporary reference. 

You: Where’s SDK Manager? 

Me: In Android Studio, go to Tools → SDK Manager. Copy the SDK location, ensure your target platform is installed, and note the platform version so you know which library to reference. 

You: I’m on Android 16.0. 

Me: Perfect—ensure that platform is installed in SDK Manager. After that, regenerate your Javadocs. 

You: I don’t see the library file people mention. 

Me: That usually means the platform isn’t installed yet or you’re looking in the wrong folder. In SDK Manager, install the exact “SDK Platform” for your API level. Then the platform folder appears, and you can try again. 

You: How do I verify Javadocs worked? 

Me: Open the main index.html under app/javadocs. It should redirect to your package page. You should see entries for your two classes, each with class descriptions and method docs. 

You: Tests ran. Build successful. 

Me: Great. Now we’re ready for the participation exercise. 

You: Please help with the participation exercise—uniquely designed, student-friendly, and matching the slides. 
Me: We’ll add three behaviors to CityList: 
A membership check that returns true when a city with the same name and province is present. 
A delete operation that removes that logical city and throws an exception if it’s absent. 
A counter that returns the current number of stored cities. 
We’ll keep the identity rule explicit (name + province), which mirrors the slides’ spirit but avoids relying on object equality overrides. Internally, we’ll centralize the “find a matching entry” logic so the other two operations can call it, which keeps things clean and easy to read. 

You: Where do I put the tests? 

Me: In the same test file you already have. Add three tests: 
One that adds a city and confirms the membership check returns true for a freshly created instance with the same name and province, and false for a different one. 
One that adds two cities, deletes one by logical identity, confirms the size updates and membership flips, then tries deleting it again and expects an exception. 
One that starts at zero, adds two, asserts two, deletes one, asserts one. 

You: I copied everything. How do I confirm I’m meeting the rubric? 

Me: Quick audit: 
Project name and package match exactly. 
City has private fields, getters, is comparable by city name, and has concise, clear documentation. 
CityList has a private list, an add method that throws for duplicates, a getter that returns the list sorted, and the three participation behaviors with clear documentation. 
Unit tests include the initial add/get tests and the three participation tests; all pass. 
Javadocs live in app/javadocs and show both classes and all methods. 
Any temporary platform reference you added for Javadoc has been removed. 

You: I tried generating docs again and it only documented test files. 

Me: In the Javadoc dialog you’re seeing (the newer UI), make sure “Module ‘app’” is selected at the top and uncheck “Include test sources.” Then generate. If it still says no sources, confirm your two class files actually live under the main/java/... package path and that the package declaration at the top of each class matches the folder path. 

You: It says “no Java sources found in the selected scope.” 

Me: That means the generator didn’t detect any Java files in the selected area. Verify your files sit under the app module’s src/main/java/... folder, not under the test folders or a Kotlin folder. Once they’re in the right place, try again with test sources unchecked. 

You: After fixing the selection, Javadocs generated. 

Me: Excellent. Open the package summary and confirm both classes are listed with their method docs. 

You: Okay, the class pages show up. 

Me: You’re done with the participation exercise. Final step: run the unit tests once more, check the HTML test report, and take a quick screenshot of the Javadocs class page. That aligns perfectly with typical grading checks. 

You: Everything’s green; docs are there. 

Me: You’re all set: requirements met, tests passing, docs generated, and your implementations follow the slides while being clearly your own. 
